/**
 * Service API unifi√© pour coordonner le frontend avec les edge functions
 * Centralise tous les appels aux edge functions avec gestion d'erreurs coh√©rente
 */

import { supabase } from '@/integrations/supabase/client';

// Types pour les r√©ponses API
export interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

export interface GuestLinkResponse {
  success: boolean;
  propertyId: string;
  bookingId: string | null;
  token: string;
  property: any;
  booking?: any;
}

export interface GuestInfoParams {
  propertyId: string;
  token: string;
  bookingData: {
    checkInDate: string;
    checkOutDate: string;
    numberOfGuests: number;
  };
  guestData: {
    guests: Array<{
      fullName: string;
      dateOfBirth?: string;
      nationality?: string;
      documentNumber?: string;
      documentType?: string;
      profession?: string;
      motifSejour?: string;
      adressePersonnelle?: string;
      email?: string;
    }>;
    documentUrls?: string[];
  };
}

export interface ContractSignatureParams {
  bookingId: string;
  signerName: string;
  signerEmail?: string | null;
  signerPhone?: string | null;
  signatureDataUrl: string;
}

export class ApiService {
  /**
   * R√©soudre un lien invit√© avec gestion d'erreurs robuste
   */
  static async resolveGuestLink(params: {
    propertyId?: string;
    token?: string;
    airbnbCode?: string;
  }): Promise<GuestLinkResponse> {
    try {
      console.log('üîç ApiService.resolveGuestLink called with:', params);

      const { data, error } = await supabase.functions.invoke('resolve-guest-link', {
        body: {
          propertyId: params.propertyId,
          token: params.token,
          airbnbCode: params.airbnbCode
        }
      });

      if (error) {
        console.error('‚ùå resolve-guest-link error:', error);
        throw new Error(error.message || 'Erreur lors de la r√©solution du lien invit√©');
      }

      if (!data || !data.success) {
        throw new Error('R√©ponse invalide de resolve-guest-link');
      }

      console.log('‚úÖ resolve-guest-link success:', data);
      return data as GuestLinkResponse;

    } catch (error) {
      console.error('‚ùå ApiService.resolveGuestLink error:', error);
      
      // Fallback: essayer de r√©cup√©rer les donn√©es directement
      if (params.propertyId) {
        console.log('üîÑ Tentative de fallback avec propertyId:', params.propertyId);
        return await this.fallbackResolveGuestLink(params.propertyId, params.token);
      }
      
      throw error;
    }
  }

  /**
   * Fallback pour resolveGuestLink en cas d'√©chec de l'edge function
   */
  private static async fallbackResolveGuestLink(
    propertyId: string, 
    token?: string
  ): Promise<GuestLinkResponse> {
    try {
      console.log('üîÑ Fallback: r√©cup√©ration directe des donn√©es...');

      const { data: property, error: propertyError } = await supabase
        .from('properties')
        .select('id, name, address, contract_template, contact_info, house_rules')
        .eq('id', propertyId)
        .single();

      if (propertyError) {
        throw new Error(`Propri√©t√© non trouv√©e: ${propertyError.message}`);
      }

      // Rechercher une r√©servation r√©cente
      const { data: bookings } = await supabase
        .from('bookings')
        .select('*')
        .eq('property_id', propertyId)
        .in('status', ['active', 'pending', 'confirmed'])
        .order('created_at', { ascending: false })
        .limit(1);

      const booking = bookings?.[0] || null;

      const fallbackResponse: GuestLinkResponse = {
        success: true,
        propertyId: propertyId,
        bookingId: booking?.id || null,
        token: token || '',
        property: property,
        booking: booking
      };

      console.log('‚úÖ Fallback r√©ussi:', fallbackResponse);
      return fallbackResponse;

    } catch (error) {
      console.error('‚ùå Fallback √©chou√©:', error);
      throw new Error(`Fallback √©chou√©: ${error instanceof Error ? error.message : 'Erreur inconnue'}`);
    }
  }

  /**
   * Soumettre les informations d'un invit√©
   */
  static async submitGuestInfo(params: GuestInfoParams): Promise<ApiResponse> {
    try {
      console.log('üìù ApiService.submitGuestInfo called');

      const { data, error } = await supabase.functions.invoke('submit-guest-info', {
        body: params
      });

      if (error) {
        console.error('‚ùå submit-guest-info error:', error);
        throw new Error(error.message || 'Erreur lors de la soumission des informations invit√©');
      }

      console.log('‚úÖ submit-guest-info success:', data);
      return data as ApiResponse;

    } catch (error) {
      console.error('‚ùå ApiService.submitGuestInfo error:', error);
      throw error;
    }
  }

  /**
   * Sauvegarder une signature de contrat
   */
  static async saveContractSignature(params: ContractSignatureParams): Promise<ApiResponse> {
    try {
      console.log('‚úçÔ∏è ApiService.saveContractSignature called');

      const { data, error } = await supabase.functions.invoke('save-contract-signature', {
        body: params
      });

      if (error) {
        console.error('‚ùå save-contract-signature error:', error);
        throw new Error(error.message || 'Erreur lors de la sauvegarde de la signature');
      }

      console.log('‚úÖ save-contract-signature success:', data);
      return data as ApiResponse;

    } catch (error) {
      console.error('‚ùå ApiService.saveContractSignature error:', error);
      throw error;
    }
  }

  /**
   * Synchroniser les documents
   */
  static async syncDocuments(bookingId: string, documentType: string = 'all'): Promise<ApiResponse> {
    try {
      console.log('üîÑ ApiService.syncDocuments called for booking:', bookingId);

      const { data, error } = await supabase.functions.invoke('sync-documents', {
        body: {
          bookingId: bookingId,
          documentType: documentType
        }
      });

      if (error) {
        console.error('‚ùå sync-documents error:', error);
        throw new Error(error.message || 'Erreur lors de la synchronisation des documents');
      }

      console.log('‚úÖ sync-documents success:', data);
      return data as ApiResponse;

    } catch (error) {
      console.error('‚ùå ApiService.syncDocuments error:', error);
      throw error;
    }
  }

  /**
   * G√©n√©rer des documents (contrat et fiches de police)
   */
  static async generateDocuments(bookingId: string): Promise<ApiResponse> {
    try {
      console.log('üìÑ ApiService.generateDocuments called for booking:', bookingId);

      // G√©n√©rer le contrat
      const { data: contractData, error: contractError } = await supabase.functions.invoke('generate-contract', {
        body: {
          bookingId: bookingId,
          action: 'generate'
        }
      });

      if (contractError) {
        console.error('‚ùå generate-contract error:', contractError);
        throw new Error(contractError.message || 'Erreur lors de la g√©n√©ration du contrat');
      }

      console.log('‚úÖ generate-contract success:', contractData);

      // G√©n√©rer les fiches de police
      const { data: policeData, error: policeError } = await supabase.functions.invoke('generate-police-forms', {
        body: {
          bookingId: bookingId
        }
      });

      if (policeError) {
        console.error('‚ùå generate-police-forms error:', policeError);
        throw new Error(policeError.message || 'Erreur lors de la g√©n√©ration des fiches de police');
      }

      console.log('‚úÖ generate-police-forms success:', policeData);

      // Retourner les deux r√©sultats
      return {
        success: true,
        contract: contractData,
        police: policeData,
        message: 'Documents g√©n√©r√©s avec succ√®s'
      } as ApiResponse;

    } catch (error) {
      console.error('‚ùå ApiService.generateDocuments error:', error);
      throw error;
    }
  }

  /**
   * Obtenir un r√©sum√© de v√©rification de r√©servation
   */
  static async getBookingVerificationSummary(bookingId: string): Promise<ApiResponse> {
    try {
      console.log('üìä ApiService.getBookingVerificationSummary called for booking:', bookingId);

      const { data, error } = await supabase.functions.invoke('get-booking-verification-summary', {
        body: {
          bookingId: bookingId
        }
      });

      if (error) {
        console.error('‚ùå get-booking-verification-summary error:', error);
        throw new Error(error.message || 'Erreur lors de la r√©cup√©ration du r√©sum√©');
      }

      console.log('‚úÖ get-booking-verification-summary success:', data);
      return data as ApiResponse;

    } catch (error) {
      console.error('‚ùå ApiService.getBookingVerificationSummary error:', error);
      throw error;
    }
  }

  /**
   * M√©thode utilitaire pour tester la connectivit√©
   */
  static async testConnectivity(): Promise<boolean> {
    try {
      const { data, error } = await supabase
        .from('properties')
        .select('count')
        .limit(1);

      if (error) {
        console.error('‚ùå Test de connectivit√© √©chou√©:', error);
        return false;
      }

      console.log('‚úÖ Test de connectivit√© r√©ussi');
      return true;
    } catch (error) {
      console.error('‚ùå Test de connectivit√© √©chou√©:', error);
      return false;
    }
  }
}
